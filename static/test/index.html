<html>
<meta charset="utf-8">
<title>Mocha Tests</title>
<link rel="stylesheet" href="mocha.css">
<script src="expect.js"></script>
<script src="mocha.js"></script>
<script src="../socket.io/socket.io.js"></script>
<script src="../underscore.min.js"></script>
<script src="../jquery.min.js"></script>
<script src="../pretty-date.js"></script>
<script src="../linkify.js"></script>
<script src="../users.js"></script>
<script src="../user-list-view.js"></script>
<script>
mocha.setup('bdd');

// On Firefox this is a lazy property that sometimes is set while tests
// are running, which triggers an erroneous 'global leak detected' error,
// so let's just make sure it gets put into the global namespace now.
window.getInterface = null;

describe('UserListView', function() {
  it('should contain added users', function() {
    var view = new UserListView(new Users(), $('<div></div>'));
    view.users.add(["bob", "jane"], "#a");
    expect(view.el.children()).to.have.length(2);
  });

  it('should order users alphabetically & case-insensitively', function() {
    var view = new UserListView(new Users(), $('<div></div>'));
    view.users.add(["c", "B", "a", "D"], "#a");
    expect(view.el.find(".nick").text()).to.be("aBcD");
  });

  it('should not contain duplicate entries', function() {
    var view = new UserListView(new Users(), $('<div></div>'));
    view.users.add(["bob", "jane"], "#a");
    view.users.add(["joe", "jane"], "#a");
    expect(view.el.find(".nick").text()).to.be("bobjanejoe");
  });

  it('should not contain removed users', function() {
    var view = new UserListView(new Users(), $('<div></div>'));
    view.users.add(["bob", "jane"], "#a");
    view.users.add(["joe", "jane"], "#b");
    view.users.remove("bob");
    expect(view.el.find(".nick").text()).to.be("janejoe");
    view.users.remove("joe", "#b");
    expect(view.el.find(".nick").text()).to.be("jane");
  });

  it('should contain renamed users', function() {
    var view = new UserListView(new Users(), $('<div></div>'));
    view.users.add(["bob", "jane"], "#a");
    view.users.rename("bob", "zangief");
    expect(view.el.find(".nick").text()).to.be("janezangief");
  });
});

describe('Users.getAllChannels()', function() {
  it('should work', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["jim", "jane"], "#b");
    expect(users.getAllChannels().sort()).to.eql(["#a", "#b"]);
  });
});

describe('Users.rename()', function() {
  it('should work', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    var bob = users.get("bob");
    users.rename("bob", "bob-away");
    expect(users.get("bob-away")).to.be(bob);
    expect(users.get("bob")).to.be(null);
  });

  it('should not throw if nick does not exist', function() {
    var users = new Users();
    users.rename("flop", "goof");
  });
});

describe('Users.add()', function() {
  it('should append to channel list', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["bob", "jane"], "#b");    
    expect(users.get("bob").channels).to.eql(["#a", "#b"]);
  });

  it('should not include duplicate channels', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["bob", "jane"], "#a");
    expect(users.get("bob").channels).to.eql(["#a"]);
  });
});

describe('Users.remove()', function() {
  it('should remove entire user when no channel is specified', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["bob", "jane"], "#b");
    users.remove(["bob"]);
    expect(users.get("bob")).to.be(null);
  });

  it('should remove channel when one is specified', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["bob", "jane"], "#b");
    users.remove(["bob"], "#a");
    expect(users.get("bob").channels).to.eql(["#b"]);
  });

  it('should remove user when their last channel is removed', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["bob", "jane"], "#b");
    users.remove(["bob"], "#a");
    users.remove(["bob"], "#b");
    expect(users.get("bob")).to.be(null);
  });

  it('should not throw when a bad nick is passed', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.remove(["flog"]);
  });
  
  it('should not throw when a bad channel is passed', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.remove(["bob"], "#b");
    expect(users.get("bob").channels).to.eql(["#a"]);
  });

  it('should not throw when a bad nick and channel are passed', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.remove(["flog"], "#b");
    expect(users.get("bob").channels).to.eql(["#a"]);
  });

});

describe('Users.removeChannel()', function() {
  it('should remove a channel from all users', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.add(["bob", "jane"], "#b");
    users.removeChannel("#a");
    expect(users.get("bob").channels).to.eql(["#b"]);
    expect(users.get("jane").channels).to.eql(["#b"]);
  });

  it('should remove users who no longer have any channels', function() {
    var users = new Users();
    users.add(["bob", "jane"], "#a");
    users.removeChannel("#a");
    expect(users.get("bob")).to.be(null);
    expect(users.get("jane")).to.be(null);
  });
});

describe('linkifyTextToHTML', function() {
  it('should wrap solitary URLs in anchor tags', function() {
    expect(linkifyTextToHTML('http://foo.com'))
      .to.be('<a href="http://foo.com">http://foo.com</a>');
  });

  it('should wrap URLs in beginning of text in anchor tags', function() {
    expect(linkifyTextToHTML('hi http://foo.com'))
      .to.be('hi <a href="http://foo.com">http://foo.com</a>');
  });

  it('should wrap URLs in end of text in anchor tags', function() {
    expect(linkifyTextToHTML('http://foo.com, dawg.'))
      .to.be('<a href="http://foo.com">http://foo.com</a>, dawg.');
  });

  it('should wrap URLs in middle of text in anchor tags', function() {
    expect(linkifyTextToHTML('it is http://foo.com.'))
      .to.be('it is <a href="http://foo.com">http://foo.com</a>.');
  });

  it('should wrap multiple URLs in anchor tags', function() {
    expect(linkifyTextToHTML('they are http://foo.com and http://bar.com.'))
      .to.be('they are <a href="http://foo.com">http://foo.com</a> and ' +
             '<a href="http://bar.com">http://bar.com</a>.');
  });

  it('should wrap https URLs in anchor tags', function() {
    expect(linkifyTextToHTML('https://foo.com'))
      .to.be('<a href="https://foo.com">https://foo.com</a>');
  });

  it('should not wrap javascript: URLs', function() {
    expect(linkifyTextToHTML('javascript:alert("NO U")'))
      .to.be('javascript:alert("NO U")');
  });

  it('should accept a callback that modifies the anchor', function() {
    expect(linkifyTextToHTML('http://foo.com', function(a) {
      a.setAttribute("href", "http://different.com");
    })).to.be('<a href="http://different.com">http://foo.com</a>');
  });
});

describe('prettyDate()', function() {
  it('should return "in the future" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now+1, now)).to.be("in the future");
  });

  it('should return "just now" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now+1)).to.be("just now");
  });

  it('should return "1 minute ago" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60)).to.be("1 minute ago");
  });

  it('should return "2 minutes ago" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60*2)).to.be("2 minutes ago");
  });

  it('should return "1 hour ago" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60*60)).to.be("1 hour ago");
  });

  it('should return "2 hours ago" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60*60*2)).to.be("2 hours ago");
  });

  it('should return "Yesterday" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60*60*24)).to.be("Yesterday");
  });

  it('should return "7 days ago" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60*60*24*7)).to.be("7 days ago");
  });

  it('should return "2 weeks ago" when appropriate', function() {
    var now = Date.now();
    expect(prettyDate(now, now + 1000*60*60*24*14)).to.be("2 weeks ago");
  });
});
</script>
<script>
onload = function() {
  mocha.run();
};
</script>
<div id="mocha"></div>
